
!> \mainpage Numerical analysis main page
!>
!> Most of the functions for numerical analysis are in the \ref numa module.
!>
!> The source code is hosted on github:
!>
!> https://github.com/JeffIrwin/numerical-analysis
!>
!> This documentation is automatically generated by Doxygen.
!>

!===============================================================================

#include "panic.F90"

!> Main public-facing module for numerical analysis
module numa

	use numa__blarg
	use numa__core
	use numa__integrate
	use numa__interp
	use numa__linalg
	use numa__linprog
	use numa__utils

	implicit none

	! TODO:
	!
	! - this file is too long. it might be good to split it up roughly
	!   per-chapter, e.g. into interpolate.f90, (fft.f90,) integrate.f90, etc.
	!   * wip
	!   * linalg is started. lots of other stuff should move there too
	!   * exercises need split up too
	! - Add ci/cd testing with ifx.  There are a couple workarounds in here
	!   specifically for Intel, e.g. initialization of complex arrays
	! - Add more doxygen doc strings, maybe at least just a `brief` for each
	!   public fn.  See `lagrange_interpolator()` which has an example doc
	!   string

contains

!********

subroutine hess(a, u)
	! Apply the Householder Hessenberg reduction to `a`
	!
	! Source:  https://dspace.mit.edu/bitstream/handle/1721.1/75282/18-335j-fall-2006/contents/lecture-notes/lec14.pdf
	use numa__blarg
	use numa__utils
	double precision, intent(inout) :: a(:,:)
	double precision, allocatable, optional, intent(out) :: u(:,:)
	!********

	integer :: i, j, k, n
	double precision :: va
	double precision, allocatable :: v(:), vv(:,:)

	n = size(a,1)
	if (present(u)) allocate(vv(n, n-2))

	do k = 1, n-2

		v = a(k+1:, k)
		v(1) = v(1) + sign_(v(1)) * norm2(v)
		v = v / norm2(v)

		! Avoiding `v` temp array might be a little more work than worthwhile,
		! impossible if `u` is present
		do j = k, n
			va = 2 * dot_product(v, a(k+1:, j))
			a(k+1:, j) = a(k+1:, j) - va * v
		end do
		do i = 1, n
			va = 2 * dot_product(v, a(i, k+1:))
			a(i, k+1:) = a(i, k+1:) - va * v
		end do

		if (present(u)) vv(1: size(v), k) = v

	end do
	if (.not. present(u)) return

	u = eye(n)
	do k = n-2, 1, -1

		v = vv(1: n-k, k)
		do j = k+1, n
			va = 2 * dot_product(v, u(k+1:, j))
			u(k+1:, j) = u(k+1:, j) - va * v
		end do

	end do
	!print *, "u = "
	!print "(4es15.5)", u

end subroutine hess

!===============================================================================

function eig_basic_qr(a, iters, iostat) result(eigvals)
	! Get the real eigenvalues of `a` using `iters` iterations of the basic QR
	! algorithm.  Many iterations may be required for good convergence with
	! large sized `a`
	!
	! The matrix `a` is modified in the process by QR decomposition
	!
	! This only supports real eigenvalues.  The same algorithm could be adapted
	! for complex eigenvalues:
	!
	!     https://math.stackexchange.com/a/3072781/232771
	!
	! The basic idea is that `a` converges to a "quasi-triangular" real matrix
	! in this algorithm.  Where the off-triangle approaches 0, we have real
	! eigenvalues.  Where there is a non-zero in the off-diagonal, we have a
	! complex conjugate pair of eigenvalues, which could be computed as the same
	! eigenvalue of its 2x2 sub-matrix block
	!
	! A better algorithm would also take a tolerance rather than a fixed number
	! of iterations
	!
	! But it's not a good idea to waste time on such improvements for as slow an
	! algorithm as basic QR.  Rather, wait and do the good work on something
	! better like Hessenberg QR, or better yet, a shifting algorithm

	use numa__utils
	double precision, intent(inout) :: a(:,:)
	double precision, allocatable :: eigvals(:)
	integer, intent(in) :: iters
	integer, optional, intent(out) :: iostat
	!********

	character(len = :), allocatable :: msg
	double precision, allocatable :: diag_(:), q(:,:)
	integer :: i, io

	if (present(iostat)) iostat = 0

	do i = 1, iters
		call qr_factor(a, diag_, iostat = io)
		if (io /= 0) then
			msg = "qr_factor() failed in eig_basic_qr()"
			call PANIC(msg, present(iostat))
			iostat = 1
			return
		end if

		! Could also do a = transpose(qr_mul_transpose(), transpose(r)),
		! but two transposes seems expensive
		q = qr_get_q_expl(a, diag_)
		a = matmul_triu_ge(a, q)
	end do
	!print *, "a = "
	!print "(4es15.5)", a

	eigvals = sorted(diag(a))
	!print *, "eigvals = ", eigvals

end function eig_basic_qr

!===============================================================================

function eig_hess_qr(a, iters, eigvecs) result(eigvals)
	! Get the real eigenvalues of `a` using `iters` iterations of the Hessenberg
	! QR algorithm

	use numa__blarg
	use numa__utils
	double precision, intent(inout) :: a(:,:)
	double precision, allocatable :: eigvals(:)
	integer, intent(in) :: iters
	double precision, optional, allocatable, intent(out) :: eigvecs(:,:)
	!********

	double precision :: h1, h2, rad, givens(2,2)
	double precision, allocatable :: c(:), s(:), &
		pq(:,:), r(:,:)
	integer :: i, k, n

	n = size(a, 1)
	allocate(c(n-1), s(n-1))

	! The matrix `pq` is the product of Q from each step.  Unlike basic QR, we
	! can't initialize pq to eye here.  Instead, we need an initial
	! transformation from the Hessenberg reduction
	call hess(a, pq)

	do i = 1, iters

		do k = 1, n-1
			h1 = a(k, k)
			h2 = a(k+1, k)

			rad = norm2([h1, h2])
			!print *, "rad = ", rad
			c(k) =  h1 / rad
			s(k) = -h2 / rad
			givens(1,:) = [c(k), -s(k)]
			givens(2,:) = [s(k),  c(k)]

			! Ref:  https://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter4.pdf
			a(k:k+1, k:) = matmul(givens, a(k:k+1, k:))

		end do
		!print *, "r = "
		!print "(4es15.5)", a

		!! If you stop here, `a` has been overwritten with `r` from its QR
		!! factorization.  You could also compute Q by applying the matmuls in the
		!! loop above to an initial identity matrix, but we don't need Q explicitly
		!! for a Hessenberg QR step
		!stop

		! The rest of the Hessenberg QR step is not part of the QR factorization,
		! rather, it overwrites `a` with R * Q

		! Apply the Givens rotations from the right
		do k = 1, n-1
			givens(1,:) = [ c(k), s(k)]  ! note this is transposed compared to above
			givens(2,:) = [-s(k), c(k)]
			a(1: k+1, k: k+1) = matmul(a(1: k+1, k: k+1), givens)

			if (.not. present(eigvecs)) cycle

			! Update Q product
			pq(:, k:k+1) = matmul(pq(:, k:k+1), givens)

		end do

	end do
	!print *, "a = "
	!print "(4es15.5)", a

	! Don't sort the eigvals, because that will break the ordering of eigvecs
	!eigvals = sorted(diag(a))

	eigvals = diag(a)

	if (.not. present(eigvecs)) return
	!********

	r = triu(a)
	!print *, "r = "
	!print "(4es15.5)", r

	! In order to get the eigenvectors of `a`, we first have to get the
	! eigenvectors of `r` and then transform them by `pq`
	!
	! Ref:  https://math.stackexchange.com/a/3947396/232771
	!
	! Especially the linked code:  https://gist.github.com/uranix/2b4bb821a0e3ffc4531bec547ea67727

	! Find the eigenvectors of `r`
	eigvecs = eye(n)
	do i = 2, n
		! scalar * eye could be optimized here to skip zeros
		eigvecs(1: i-1, i) = invmul(r(i,i) * eye(i-1) - r(:i-1, :i-1), r(:i-1, i))
	end do
	!print *, "R eigvecs = "
	!print "(4es15.5)", eigvecs

	eigvecs = matmul(pq, eigvecs)
	!print *, "eigvecs hess qr = "
	!print "(4es15.5)", eigvecs

	!print *, "a * w / w ="
	!print "(4es15.5)", matmul(a0, eigvecs) / eigvecs

end function eig_hess_qr

!===============================================================================

function house(x, iostat) result(pp)
	! Return the Householder reflector `pp` such that pp * x == [1, 0, 0, ...]
	!
	! Could just return `v` like house_c64(), but this fn is only used for 3x3
	! matrices, whereas house_c64() runs on arbitrarily large matrices for QR
	! factoring

	use numa__blarg
	use numa__utils
	double precision, intent(in) :: x(:)
	double precision, allocatable :: pp(:,:)
	integer, optional, intent(out) :: iostat
	!********

	character(len = :), allocatable :: msg
	double precision :: alpha, normv
	double precision, allocatable :: v(:)
	integer :: n

	if (present(iostat)) iostat = 0

	n = size(x)

	alpha = -sign_(x(1)) * norm2(x)
	v = x
	v(1) = v(1) - alpha

	normv = norm2(v)
	if (normv <= 0) then
		v = v * 1.d50
		normv = norm2(v)
		!print *, "normv = ", normv
		!print *, "v/normv = ", v / normv

		pp = eye(n)
		!print *, "v = ", v
		msg = "vector is singular in house()"
		call PANIC(msg, present(iostat))
		iostat = 1
		return
	end if
	v = v / normv

	pp = eye(n) - 2.d0 * outer_product(v, v)

	!print *, "in house():"
	!print *, "x = ", x
	!print *, "pp = "
	!print "(3es15.5)", pp
	!print *, "pp * x = ", matmul(pp, x)

end function house

!===============================================================================

function eig_lapack(aa, eigvecs, iostat) result(eigvals)
	! Get the eigenvalues of `aa` using the Francis double step QR algorithm,
	! using LAPACK's dlahqr() routine (but still my home-made hess() routine)

	use numa__blarg
	use numa__dlahqr
	use numa__utils
	double precision, intent(inout) :: aa(:,:)
	double complex, allocatable :: eigvals(:)
	double complex, optional, allocatable, intent(out) :: eigvecs(:,:)
	integer, optional, intent(out) :: iostat
	!********

	character(len = :), allocatable :: msg
	double complex, allocatable :: ca(:,:), cq(:,:)
	double precision, parameter :: eps = 1.d-10
	double precision, allocatable :: pq(:,:)
	integer :: i, n

	if (present(iostat)) iostat = 0

	n = size(aa, 1)

	if (present(eigvecs)) then
		! The matrix `pq` is the product of Q from each step.  Unlike basic QR, we
		! can't initialize pq to eye here.  Instead, we need an initial
		! transformation from the Hessenberg reduction
		call hess(aa, pq)
	else
		call hess(aa)
	end if
	!print *, "aa = "
	!print "("//to_str(n)//"es19.9)", aa

	block
		double precision, allocatable :: wr(:), wi(:)
		integer :: ilo, ihi, ldh, iloz, ihiz, ldz, info
		logical :: wantt, wantz

		! Set indices to factorize all of `aa`, not just a slice
		ilo = 1
		ihi = n
		ldh = n
		iloz = 1
		ihiz = n
		ldz = n

		! Eigval real/imag components
		allocate(wr(n), wi(n))

		if (present(eigvecs)) then
			wantt = .true.  ! want full schur form, not just eigvals
			wantz = .true.
		else
			! Intel requires allocation of `pq` for dlahqr().  For GNU it
			! doesn't matter
			allocate(pq(0,0))
			wantt = .false.
			wantz = .false.
		end if

		call dlahqr(wantt, wantz, n, ilo, ihi, aa, ldh, wr, wi, &
			iloz, ihiz, pq, ldz, info)
		if (info /= 0) then
			msg = "dlahqr() failed in eig_lapack()"
			call PANIC(msg, present(iostat))
			iostat = 1
			return
		end if

		! Copy eigvals out
		eigvals = dcmplx(wr, wi)

	end block

	!print *, "aa = "
	!print "("//to_str(n)//"es16.6)", aa
	!print *, "pq = "
	!print "("//to_str(n)//"es16.6)", pq

	if (.not. present(eigvecs)) return

	! Zero the remaining below-diagonal non-zeros
	call real_schur_to_complex(aa, pq, ca, cq, eps)

	! No eigval swapping happens with LAPACK
	!eigvals = diag(ca)

	!print *, "ca = "
	!print "("//to_str(2*n)//"es19.9)", ca

	! Find the eigenvectors of triangular `ca`
	eigvecs = eye(n)
	do i = 2, n
		eigvecs(1: i-1, i) = invmul(ca(i,i) * eye(i-1) - ca(:i-1, :i-1) , ca(:i-1, i))
	end do
	!print *, "R eigvecs = "
	!print "("//to_str(n)//"es19.9)", eigvecs

	eigvecs = matmul(cq, eigvecs)

end function eig_lapack

!===============================================================================

function eig_francis_qr(aa, eigvecs, iostat) result(eigvals)
	! Get the eigenvalues of `aa` using the Francis double step QR algorithm.
	! Use eig_lapack() instead because it's much more robust
	use numa__blarg
	use numa__utils
	double precision, intent(inout) :: aa(:,:)
	double complex, allocatable :: eigvals(:)
	double complex, optional, allocatable, intent(out) :: eigvecs(:,:)
	integer, optional, intent(out) :: iostat
	!********

	character(len = :), allocatable :: msg

	double complex :: l1, l2
	double complex, allocatable :: ca(:,:), cq(:,:)

	! I still have doubts about robustness here because this tolerance is
	! extremely sensitive
	double precision, parameter :: eps = 1.d-10  ! should eps and iters be args?

	double precision :: rad, s, tr, x, y, z, p2(2,2), p3(3,3), ck, sk, &
		a, b, c, d, det_, v(3), aii, aij, aji, ajj, a11, a12, a21, a22, a32
	double precision, allocatable :: pq(:,:)

	integer, parameter :: iters = 100
	integer :: i, i1, k, n, j, k1, iter, io

	logical, allocatable :: is_real(:)

	if (present(iostat)) iostat = 0

	n = size(aa, 1)

	if (present(eigvecs)) then
		! The matrix `pq` is the product of Q from each step.  Unlike basic QR, we
		! can't initialize pq to eye here.  Instead, we need an initial
		! transformation from the Hessenberg reduction
		call hess(aa, pq)
	else
		call hess(aa)
	end if

	!print *, "aa = "
	!print "("//to_str(n)//"es19.9)", aa

	i = n  ! i indicates the active matrix size
	iter = 0

	! LAPACK has lots of logic to scale to avoid over/under flow which is
	! skipped here and thus not robust

	do while (i > 2)
		iter = iter + 1
		if (iter > iters) then
			msg = "convergence failed in eig_francis_qr()"
			call PANIC(msg, present(iostat))
			iostat = 1
			return
		end if
		!print *, "i = ", i

		j = i - 1
		aii = aa(i,i)
		aij = aa(i,j)
		aji = aa(j,i)
		ajj = aa(j,j)

		tr = (aii + ajj) / 1          ! trace
		det_ = ajj * aii - aji * aij  ! determinant

		! Compute first 3 elements of first column of M

		a11 = aa(1,1)
		a21 = aa(2,1)
		a12 = aa(1,2)
		a22 = aa(2,2)
		a32 = aa(3,2)

		x = a11**2 + a12 * a21 - tr * a11 + det_
		y = a21 * (a11 + a22 - tr)
		z = a21 * a32

		x = x
		y = y
		z = z

		do k = 0, i-3

			! Determine the Householder reflector `p3`.  Using a scalar `s`
			! here, and for the Givens rotation below, effectively aids
			! convergence for n >~ 40
			v = [x, y, z]
			s = sum(abs(v))
			v = v / s
			p3 = house(v, io)

			if (io /= 0) then
				!print *, "x, y, z = ", x, y, z
				msg = "house() failed in eig_francis_qr()"
				call PANIC(msg, present(iostat))
				iostat = 2
				return
			end if
			!print *, "p3 = "
			!print "(3es15.5)", p3

			k1 = max(1, k)
			aa(k+1: k+3, k1:) = matmul(p3, aa(k+1: k+3, k1:))

			k1 = min(k+4, i)
			aa(:k1, k+1: k+3) = matmul(aa(:k1, k+1: k+3), p3)

			if (present(eigvecs)) then
				pq(:, k+1: k+3) = matmul(pq(:, k+1: k+3), p3)
			end if

			x = aa(k+2, k+1)
			y = aa(k+3, k+1)
			if (k < i-3) then
				z = aa(k+4, k+1)
			end if

		end do

		! Determine the 2D Givens rotation `p2`

		s = abs(x) + abs(y)
		if (s <= 0) then
			!print *, "x, y = ", x, y
			msg = "matrix is singular in eig_francis_qr()"
			call PANIC(msg, present(iostat))
			iostat = 3
			return
		end if
		x = x / s
		y = y / s

		rad = norm2([x, y])
		ck =  x / rad
		sk = -y / rad
		p2(1,:) = [ck, -sk]
		p2(2,:) = [sk,  ck]

		aa(j:i, i-2:) = matmul(p2, aa(j:i, i-2:))
		aa(:i, i-1:i) = matmul(aa(:i, i-1:i), transpose(p2))

		if (present(eigvecs)) then
			pq(:, i-1:i) = matmul(pq(:, i-1:i), transpose(p2))
		end if

		! Check for convergence

		!print *, "aa(i,j)     = ", aa(i,j)
		!print *, "aa(i-1,j-1) = ", aa(i-1,j-1)

		if (abs(aa(i,j)) < eps * (abs(aa(j,j)) + abs(aa(i,i)))) then
			!print *, "i -= 1"
			aa(i,j) = 0.d0
			i = i - 1
			iter = 0
		else if (abs(aa(i-1, j-1)) < eps * (abs(aa(j-1, j-1)) + abs(aa(j,j)))) then
			!print *, "i -= 2"
			aa(i-1, j-1) = 0.d0
			i = i - 2
			iter = 0
		end if

	end do
	!print *, "aa = "
	!print "("//to_str(n)//"es19.9)", aa
	!print *, "pq = "
	!print "("//to_str(n)//"es19.9)", pq

	! Process 2x2 block along diagonal and get their eigenvalues.  Some
	! may be real, some may be complex
	allocate(is_real(n))
	is_real = .true.
	allocate(eigvals(n))
	do i = 1, n-1
		i1 = i + 1

		! 2x2 block around diagonal
		a = aa(i , i )
		b = aa(i1, i )
		c = aa(i , i1)
		d = aa(i1, i1)

		if (abs(b) <= eps * (abs(a) + abs(d))) cycle

		tr = a + d         ! trace
		det_ = a*d - b*c  ! determinant

		! Eigenvalues of 2x2 block
		!
		! Source:  https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
		l1 = tr/2 + sqrt(dcmplx(tr**2/4 - det_))
		l2 = tr/2 - sqrt(dcmplx(tr**2/4 - det_))

		!print *, "b  = ", b
		!print *, "l1 = ", l1
		!print *, "l2 = ", l2
		!print *, ""

		is_real(i ) = .false.
		is_real(i1) = .false.

		eigvals(i ) = l1
		eigvals(i1) = l2

	end do

	! Second pass: collect the real eigenvalues not saved in the first pass
	do i = 1, n
		if (.not. is_real(i)) cycle
		eigvals(i) = aa(i,i)
	end do

	!!print *, "eigvals sorted = ", sorted(eigvals)
	!print *, "eigvals = ", eigvals

	!********
	if (.not. present(eigvecs)) return

	! Zero the remaining below-diagonal non-zeros
	call real_schur_to_complex(aa, pq, ca, cq, eps)

	! Some of the eigenvalues get swapped around in real_schur_to_complex()
	eigvals = diag(ca)

	!print *, "ca = "
	!print "("//to_str(2*n)//"es19.9)", ca

	! Find the eigenvectors of triangular `ca`
	eigvecs = eye(n)
	do i = 2, n
		! Looking at LAPACK, it has a special-purpose quasi-triangular solver
		! for this problem.  There are cases for 1x1 blocks, 2x2 blocks, and
		! real or complex eigenvectors, with all complex numbers encoded as
		! pairs of reals, without explicitly doing rsf2csf:
		!
		!     https://netlib.org/lapack/explore-html/d2/d98/group__trevc3_gaee05b7252c5a3b2b935d5a4a6101033d.html
		!
		eigvecs(1: i-1, i) = invmul(ca(i,i) * eye(i-1) - ca(:i-1, :i-1) , ca(:i-1, i))
	end do
	!print *, "R eigvecs = "
	!print "("//to_str(n)//"es19.9)", eigvecs

	eigvecs = matmul(cq, eigvecs)

	!print *, "eigvecs francis qr = "
	!print "("//to_str(n)//"es19.9)", eigvecs

end function eig_francis_qr

!===============================================================================

subroutine real_schur_to_complex(r, q, cr, cq, eps)
	! Convert real Schur form [r, q] to complex Schur form [cr, cq].  Compare
	! the MATLAB and scipy functions rsf2csf()
	!
	! Matrix `r` is quasi-triangular and `q` is unitary
	use numa__blarg
	use numa__utils
	double precision, intent(in) :: r(:,:), q(:,:)
	double complex, allocatable, intent(out) :: cr(:,:), cq(:,:)
	double precision, intent(in) :: eps
	!********

	double complex :: mu(2), cc, sc, g(2,2)

	double precision :: a, b, c, d, t, det_, rad

	integer :: i

	! Cast to complex
	cr = r
	cq = q

	do i = 2, size(r, 1)
		! Source:
		!
		!     https://github.com/scipy/scipy/blob/3fe8b5088d1b63e7557d26314cf5f40851f46a45/scipy/linalg/_decomp_schur.py#L329

		if (abs(cr(i, i-1)) <= eps * (abs(cr(i-1, i-1)) + abs(cr(i,i)))) then
			cr(i, i-1) = 0
			cycle
		end if

		!print *, "Zeroing at i = ", i
		!print *, "cr(i, i-1) = ", cr(i, i-1)

		! 2x2 block around diagonal
		a = dble(cr(i-1, i-1))
		b = dble(cr(i, i-1))
		c = dble(cr(i-1, i))
		d = dble(cr(i, i))

		t = a + d         ! trace
		det_ = a*d - b*c  ! determinant

		! Eigenvalues of 2x2 block
		mu(1) = t/2 + sqrt(dcmplx(t**2/4 - det_))
		mu(2) = t/2 - sqrt(dcmplx(t**2/4 - det_))
		!print *, "mu = ", mu

		mu(1) = mu(1) - cr(i,i)

		! Maybe this could work as a replacement for dlanv2(), but cc and sc are
		! complex, not real
		rad = norm2c([mu(1), cr(i, i-1)])
		cc = mu(1) / rad
		sc = cr(i, i-1) / rad

		g(1,:) = [conjg(cc), sc]
		g(2,:) = [-sc, cc]

		cr(i-1:i, i-1:) = matmul(g, cr(i-1:i, i-1:))
		cr(:i, i-1:i)   = matmul(cr(:i, i-1:i), transpose(conjg(g)))
		cq(: , i-1:i)   = matmul(cq(: , i-1:i), transpose(conjg(g)))

		cr(i, i-1) = 0

		!print *, "cr = "
		!print "("//to_str(2*n)//"es19.9)", cr
		!print *, ""

	end do

end subroutine real_schur_to_complex

!===============================================================================

function eig_hess_qr_kernel(a, iters, eigvecs) result(eigvals)
	! Get the real eigenvalues of `a` using `iters` iterations of the Hessenberg
	! QR algorithm
	!
	! To get the eigenvectors, find the kernel (null-space) of A-lambda*I for
	! each eigenvalue lambda

	use numa__utils, only:  sorted
	double precision, intent(inout) :: a(:,:)
	double precision, allocatable :: eigvals(:)
	integer, intent(in) :: iters
	double precision, optional, allocatable, intent(out) :: eigvecs(:,:)
	!********

	double precision :: h1, h2, rad, givens(2,2), eigval
	double precision, allocatable :: c(:), s(:), a0(:,:), &
		eigvec(:)
	integer :: i, j, k, n

	a0 = a

	n = size(a, 1)
	allocate(c(n-1), s(n-1))

	call hess(a)

	do i = 1, iters

		do k = 1, n-1
			h1 = a(k, k)
			h2 = a(k+1, k)

			rad = norm2([h1, h2])
			!print *, "rad = ", rad
			c(k) =  h1 / rad
			s(k) = -h2 / rad
			givens(1,:) = [c(k), -s(k)]
			givens(2,:) = [s(k),  c(k)]

			! Ref:  https://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter4.pdf
			a(k:k+1, k:) = matmul(givens, a(k:k+1, k:))

		end do
		!print *, "r = "
		!print "(4es15.5)", a

		!! If you stop here, `a` has been overwritten with `r` from its QR
		!! factorization.  You could also compute Q by applying the matmuls in the
		!! loop above to an initial identity matrix, but we don't need Q explicitly
		!! for a Hessenberg QR step
		!stop

		! The rest of the Hessenberg QR step is not part of the QR factorization,
		! rather, it overwrites `a` with R * Q

		! Apply the Givens rotations from the right
		do k = 1, n-1
			givens(1,:) = [ c(k), s(k)]  ! note this is transposed compared to above
			givens(2,:) = [-s(k), c(k)]
			a(1: k+1, k: k+1) = matmul(a(1: k+1, k: k+1), givens)
		end do

	end do
	!print *, "a = "
	!print "(4es15.5)", a

	! Don't sort the eigvals, because that will break the ordering of eigvecs
	!eigvals = sorted(diag(a))

	eigvals = diag(a)

	if (.not. present(eigvecs)) return
	allocate(eigvecs(n,n))

	!print *, "getting eigvecs via kernel ..."

	do i = 1, n
		eigval = eigvals(i)

		! Get eigenvector by finding the null-space of A - eigval * eye
		a = a0
		do j = 1, n
			a(j,j) = a(j,j) - eigval
		end do
		!print *, "a = "
		!print "(4es15.5)", a

		eigvec = lu_kernel(a)

		!********
		!! Find null-space using QR decomposition.  This also works
		!call qr_factor(a, diag_, iostat = io)
		!q = qr_get_q_expl(a, diag_)
		!!print *, "q = "
		!!print "(4es15.5)", q

		!! A - eigval*eye is singular, so the last row of Q will be in its null space
		!! and thus an eigenvector of A
		!!
		!! This probably won't work for eigenvalues with multiplicity.  In
		!! that case, you would need to get the last several rows and set
		!! multiple rows in the output
		!eigvec = q(:,n)
		!!print *, "eigvec = ", eigvec
		!********

		!! Confirm that it's an eigenvec.  All components of this print should be the
		!! same number
		!print *, "eigval = ", matmul(a0, eigvec) / eigvec
		!print *, "eigval = ", matmul(transpose(a0), eigvec) / eigvec

		eigvecs(:,i) = eigvec

	end do

end function eig_hess_qr_kernel

!===============================================================================

function polyfit_lu(x, y, n, iostat) result(p)
	! Fit a polynomial using LU decomposition.  The function polyfit() should be
	! used instead, which avoid unnecessary matmul's, using QR decomposition
	! instead
	!
	! Polynomial coefficients `p` are in ascending powers, unlike MATLAB's polyfit()
	use numa__utils
	double precision, intent(in) :: x(:), y(:)
	integer, intent(in) :: n
	integer, optional, intent(out) :: iostat

	double precision, allocatable :: p(:)
	!********

	character(len = :), allocatable :: msg
	double precision, allocatable :: xx(:,:), xtx(:,:)
	integer :: i, nx

	if (present(iostat)) iostat = 0

	nx = size(x)

	if (nx /= size(y)) then
		msg = "size(x) does not match size(y) in polyfit_lu()"
		call PANIC(msg, present(iostat))
		iostat = 1
		return
	end if
	if (n+1 > nx) then
		msg = "polynomial degree is too high for size of data in polyfit_lu()"
		call PANIC(msg, present(iostat))
		iostat = 2
		return
	end if
	if (n < 0) then
		msg = "polynomial degree is negative in polyfit_lu()"
		call PANIC(msg, present(iostat))
		iostat = 3
		return
	end if

	allocate(xx(nx, n+1))
	xx(:,1) = 1
	do i = 2, n+1
		xx(:,i) = x * xx(:, i-1)
	end do

	xtx = matmul(transpose(xx), xx)
	p   = matmul(transpose(xx), y)

	call lu_invmul(xtx, p)
	!print *, "p = ", p
	!print *, "y = ", y

end function polyfit_lu

!===============================================================================

function polyfit(x, y, n, iostat) result(p)
	! Polynomial coefficients `p` are in ascending powers, unlike MATLAB's polyfit()
	use numa__utils
	double precision, intent(in) :: x(:), y(:)
	integer, intent(in) :: n
	integer, optional, intent(out) :: iostat

	double precision, allocatable :: p(:)
	!********

	character(len = :), allocatable :: msg
	double precision, allocatable :: xx(:,:)
	integer :: i, nx, io

	if (present(iostat)) iostat = 0

	nx = size(x)

	if (nx /= size(y)) then
		msg = "size(x) does not match size(y) in polyfit()"
		call PANIC(msg, present(iostat))
		iostat = 1
		return
	end if
	if (n+1 > nx) then
		msg = "polynomial degree is too high for size of data in polyfit()"
		call PANIC(msg, present(iostat))
		iostat = 2
		return
	end if
	if (n < 0) then
		msg = "polynomial degree is negative in polyfit()"
		call PANIC(msg, present(iostat))
		iostat = 3
		return
	end if

	allocate(xx(nx, n+1))
	xx(:,1) = 1
	do i = 2, n+1
		xx(:,i) = x * xx(:, i-1)
	end do
	!print *, "xx = "
	!!print "("//to_str(nx)//"es16.6)", xx
	!print "("//to_str(n+1)//"es16.6)", transpose(xx)

	p = qr_solve(xx, y, allow_rect = .true., iostat = io)
	if (io /= 0) then
		msg = "qr_solve() failed in polyfit()"
		call PANIC(msg, present(iostat))
		iostat = 4
		return
	end if

end function polyfit

!===============================================================================

function polyval(p, x) result(y)
	double precision, intent(in) :: p(:), x(:)
	double precision, allocatable :: y(:)
	!********
	double precision, allocatable :: xpow(:)
	integer :: j, nx

	nx = size(x)
	allocate(y(nx))

	y = p(1)
	xpow = x
	do j = 2, size(p)
		y = y + p(j) * xpow
		xpow = xpow * x
	end do

end function polyval

!===============================================================================

function gauss_newton(x, y, f, df, beta0, iters, iostat) result(beta)
	! Use the Gauss-Newton algorithm to find parameters `beta` to fit a function
	! `f` to data `x` and `y` with an initial guess `beta0`.  The function has a
	! gradient `df` == df/dx
	!
	! This requires knowledge of the analytic derivative of f.  If the
	! derivative is not easily known, a derivative-free optimization algorithm
	! could be used instead like nelder_mead_fit()

	use numa__utils
	double precision, intent(in) :: x(:), y(:)
	procedure(fn_f64_params_to_f64) :: f
	procedure(fn_f64_params_to_vec_f64) :: df
	double precision, intent(in) :: beta0(:)
	integer, intent(in) :: iters
	integer, optional, intent(out) :: iostat

	double precision, allocatable :: beta(:)
	!********

	character(len = :), allocatable :: msg
	double precision, allocatable :: res(:), jac(:,:), delta(:)
	integer :: i, nx, nb, iter, io

	if (present(iostat)) iostat = 0

	nx = size(x)
	nb = size(beta0)
	allocate(res(nx))
	allocate(jac(nx, nb))

	beta = beta0
	do iter = 1, iters

		do i = 1, nx
			! Evaluate residual
			res(i) = y(i) - f(x(i), beta)
		end do
		!print *, "res = ", res

		do i = 1, nx
			! Evaluate Jacobian
			jac(i,:) = -df(x(i), beta)
		end do
		!print *, "jac = "
		!print "(2es16.6)", transpose(jac)

		delta = qr_solve(jac, res, allow_rect = .true., iostat = io)
		if (io /= 0) then
			msg = "qr_solve() failed in gauss_newton()"
			call PANIC(msg, present(iostat))
			iostat = 1
			return
		end if

		beta = beta - delta

	end do

end function gauss_newton

!===============================================================================

function nelder_mead_fit(x, y, f, beta0, beta_tol, iters) result(beta)
	! Fit data `x` and `y` by finding `beta` in order to minimize 
	! norm2(y - f(x, beta))
	!
	! This is 1D in terms of `x` and `y` for now, i.e. `f` takes a scalar `x`
	! and returns a scalar `y`, but it could probably be generalized to
	! multidimensional fns, and more easily so than gauss_newton().  The
	! parameters `beta` of course can have any size/dimension
	!
	! Maybe this should have an f_tol option instead of or in addition too
	! beta_tol

	use numa__utils
	double precision, intent(in) :: x(:), y(:)
	procedure(fn_f64_params_to_f64) :: f
	double precision, intent(in) :: beta0(:)
	double precision, optional, intent(in) :: beta_tol
	integer, optional, intent(in) :: iters

	double precision, allocatable :: beta(:)
	!********

	double precision :: fr, fe, fc, beta_tol_
	double precision, parameter :: alpha_ = 1, gamma_ = 2, rho_ = 0.5, sigma_ = 0.5
	double precision, allocatable :: bs(:,:), fs(:), bo(:), br(:), &
		be(:), bc(:)

	integer :: i, nx, nb, nb1, iter, iters_
	integer, allocatable :: idx(:)

	logical :: converged

	beta_tol_ = 1.d-3
	iters_ = 1000
	if (present(beta_tol)) beta_tol_ = beta_tol
	if (present(iters)) iters_ = iters

	nx = size(x)
	nb = size(beta0)
	nb1 = nb + 1  ! number of simplex points

	! Initial simplex
	allocate(bs(nb, nb1))
	do i = 1, nb
		bs(:,i) = beta0
		bs(i,i) = bs(i,i) + 1
	end do
	bs(:,nb1) = beta0

	! Evaluate fn on initial simplex
	allocate(fs(nb1))
	do i = 1, nb1
		fs(i) = nm_eval_res(bs(:,i))
	end do
	!print *, "fs init = ", fs

	converged = .false.
	do iter = 1, iters_

		! Sort
		call sortidx_f64_1(fs, idx)
		!print *, "idx = ", idx

		fs = fs(idx)
		bs = bs(:, idx)
		!print *, "fs = ", fs

		!print *, "bs = "
		!print "(2es16.6)", bs

		! Note: this is a bad criterion because 1 and nb1 may not be
		! representative of the simplex size
		if (norm2(bs(:,1) - bs(:,nb1)) < beta_tol_) then
			!print *, "iter = ", iter
			converged = .true.
			exit
		end if

		! Centroid
		bo = sum(bs(:, 1: nb), dim = 2) / nb
		!print *, "bo = ", bo

		! Reflect
		br = bo + alpha_ * (bo - bs(:,nb1))
		fr = nm_eval_res(br)

		if (fs(1) <= fr .and. fr < fs(nb)) then
			! Replace
			fs(nb1) = fr
			bs(:,nb1) = br
			cycle
		end if

		if (fr < fs(1)) then
			! Expand
			be = bo + gamma_ * (br - bo)
			fe = nm_eval_res(be)

			if (fe < fr) then
				fs(nb1) = fe
				bs(:,nb1) = be
			else
				fs(nb1) = fr
				bs(:,nb1) = br
			end if
			cycle
		end if

		if (fr < fs(nb1)) then
			! Contract outward
			bc = bo + rho_ * (br - bo)
			fc = nm_eval_res(bc)

			if (fc < fr) then
				fs(nb1) = fc
				bs(:,nb1) = bc
				cycle
			end if

		else
			! Contract inward
			bc = bo + rho_ * (bs(:,nb1) - bo)
			fc = nm_eval_res(bc)

			if (fc < fs(nb1)) then
				fs(nb1) = fc
				bs(:,nb1) = bc
				cycle
			end if

		end if

		! Shrink
		do i = 2, nb1
			bs(:,i) = bs(:,1) + sigma_ * (bs(:,i) - bs(:,1))
			fs(i) = nm_eval_res(bs(:,i))
		end do

	end do

	if (.not. converged) then
		write(*,*) YELLOW // "Warning" // COLOR_RESET // &
			": nelder_mead_fit() has not converged"
	end if
	beta = bs(:,1)

	!--------------------------------
	contains

		double precision function nm_eval_res(beta_) result(res)
			! Evaluate the residual and sum its squares
			double precision, intent(in) :: beta_(:)
			integer :: k
			res = 0
			do k = 1, nx
				res = res + (y(k) - f(x(k), beta_)) ** 2
			end do
		end function nm_eval_res

end function nelder_mead_fit

!===============================================================================

function nelder_mead(f, x0, x_tol, iters) result(x)
	! Solve an optimization problem by finding `x` in order to minimize 
	! f(x)

	use numa__utils
	procedure(fn_vec_f64_to_f64) :: f
	double precision, intent(in) :: x0(:)
	double precision, optional, intent(in) :: x_tol
	integer, optional, intent(in) :: iters

	double precision, allocatable :: x(:)
	!********

	double precision :: fr, fe, fc, x_tol_
	double precision, parameter :: alpha_ = 1, gamma_ = 2, rho_ = 0.5, sigma_ = 0.5
	double precision, allocatable :: xs(:,:), fs(:), xo(:), xr(:), &
		xe(:), xc(:)

	integer :: i, nb, nb1, iter, iters_
	integer, allocatable :: idx(:)

	logical :: converged

	x_tol_ = 1.d-3
	iters_ = 1000
	if (present(x_tol)) x_tol_ = x_tol
	if (present(iters)) iters_ = iters
	nb = size(x0)
	nb1 = nb + 1  ! number of simplex points

	! Initial simplex
	allocate(xs(nb, nb1))
	do i = 1, nb
		xs(:,i) = x0
		xs(i,i) = xs(i,i) + 1
	end do
	xs(:,nb1) = x0

	! Evaluate fn on initial simplex
	allocate(fs(nb1))
	do i = 1, nb1
		fs(i) = f(xs(:,i))
	end do
	!print *, "fs init = ", fs

	converged = .false.
	do iter = 1, iters_

		! Sort
		call sortidx_f64_1(fs, idx)
		!print *, "idx = ", idx

		fs = fs(idx)
		xs = xs(:, idx)
		!print *, "fs = ", fs

		!print *, "xs = "
		!print "(2es16.6)", xs

		! Note: this is a bad criterion because 1 and nb1 may not be
		! representative of the simplex size
		if (norm2(xs(:,1) - xs(:,nb1)) < x_tol_) then
			!print *, "iter = ", iter
			converged = .true.
			exit
		end if

		! Centroid
		xo = sum(xs(:, 1: nb), dim = 2) / nb
		!print *, "xo = ", xo

		! Reflect
		xr = xo + alpha_ * (xo - xs(:,nb1))
		fr = f(xr)

		if (fs(1) <= fr .and. fr < fs(nb)) then
			! Replace
			fs(nb1) = fr
			xs(:,nb1) = xr
			cycle
		end if

		if (fr < fs(1)) then
			! Expand
			xe = xo + gamma_ * (xr - xo)
			fe = f(xe)

			if (fe < fr) then
				fs(nb1) = fe
				xs(:,nb1) = xe
			else
				fs(nb1) = fr
				xs(:,nb1) = xr
			end if
			cycle
		end if

		if (fr < fs(nb1)) then
			! Contract outward
			xc = xo + rho_ * (xr - xo)
			fc = f(xc)

			if (fc < fr) then
				fs(nb1) = fc
				xs(:,nb1) = xc
				cycle
			end if

		else
			! Contract inward
			xc = xo + rho_ * (xs(:,nb1) - xo)
			fc = f(xc)

			if (fc < fs(nb1)) then
				fs(nb1) = fc
				xs(:,nb1) = xc
				cycle
			end if

		end if

		! Shrink
		do i = 2, nb1
			xs(:,i) = xs(:,1) + sigma_ * (xs(:,i) - xs(:,1))
			fs(i) = f(xs(:,i))
		end do

	end do

	if (.not. converged) then
		write(*,*) YELLOW // "Warning" // COLOR_RESET // &
			": nelder_mead() has not converged"
	end if
	x = xs(:,1)

end function nelder_mead

!===============================================================================

end module numa

